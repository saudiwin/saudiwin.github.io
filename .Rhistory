pvals_orig <- coeftest(results_ps)[-1,4]<0.05
total_sig_orig_blocker <- mean(pvals_orig)
total_sig_adj_blocker <- mean(pvals_adj)
int_sig_orig_blocker <- pvals_orig['military:int_coef']
int_sig_adj_blocker <- pvals_adj['military:int_coef']
out_results <- data_frame(int_sig_adj,int_sig_orig,int_sig_adj_blocker,int_sig_orig_blocker,
total_sig_adj,total_sig_orig,total_sig_adj_blocker,
total_sig_orig_blocker,abs_true_effect=abs(true_effect),
true_effect=true_effect,
est_effect=coef(results)['military:int_coef'],
est_effect_ps=coef(results)['military:int_coef'])
})
out_data <- bind_rows(out_data)
return(out_data)
},mc.cores=parallel::detectCores(),mc.preschedule=FALSE)
#save the data for inspection
all_sims_data <- bind_rows(all_sims) %>% mutate(sample_size=rep(sampled_seq,each=n_sims),
iter=rep(1:n_sims,times=num_breaks))
}
knitr::opts_chunk$set(echo = TRUE)
#Required packages
require(ggplot2)
require(dplyr)
require(tidyr)
require(multiwayvcov)
require(lmtest)
# package MASS also used but not loaded
# != Note this simulation uses a version of mclapply for windows. You must have R package parallelsugar installed to use it if you are running windows.
# to install parallelsugar:
# install.packages('devtools')
# library(devtools)
# install_github('nathanvan/parallelsugar')
# If using Windows, parallelfunc comes from parallesugar, otherwise the standard mclapply is used
if(.Platform$OS.type=='windows') {
parallelfunc <- parallelsugar::mclapply_socket
} else {
parallelfunc <- parallel::mclapply
}
#Actually run the simulation or just load the data and look at it?
run_sim <- TRUE
# Max number of respondents fixed at 2700
num_resp <- 2700
# Number of iterations (breaks in sample size)
num_breaks <- 300
# Number of simulations to run per iteration
n_sims <- 1000
# Two treatment variables producing a cross-product of 7x7
treatments1 <- c('military','MOI','president','MOJ','parliament','municipality','government')
treatments2 <- c('exprop.firm','exprop.income','permit.reg','contracts.supply','permit.export','permit.import','reforms')
total_treat <- length(c(treatments1,treatments2))
grid_pair <- as.matrix(expand.grid(treatments1,treatments2))
print(head(grid_pair))
if(run_sim==TRUE) {
file.create('output_log.txt',showWarnings = FALSE)
# Need to randomize over the simulations so that parallelization works correctly on windows
sampled_seq <- sample(seq(100,num_resp,length.out = num_breaks))
all_sims <- parallelfunc(sampled_seq,function(x) {
out_probs <- 1:n_sims
cat(paste0("Now running simulation on data sample size ",x),file='output_log.txt',sep='\n',append=TRUE)
out_data <- lapply(1:n_sims, function(j) {
total_probs <- sapply(1:x,function(x) {
treat_rows <- sample(1:nrow(grid_pair),4)
treatments_indiv <- c(grid_pair[treat_rows,])
return(treatments_indiv)
})
by_resp <- t(total_probs)
by_resp <- as_data_frame(by_resp)
names(by_resp) <- c(paste0('actor.',1:4,"_cluster",c(1,1,2,2)),paste0('gift.',1:4,"_cluster",c(1,1,2,2)))
by_resp$respondent <- paste0('Respondent_',1:nrow(by_resp))
by_resp <- gather(by_resp,attribute,indicator,-respondent) %>% separate(attribute,into=c('attribute','cluster'),sep='_') %>%
separate(attribute,into=c('attribute','task')) %>% spread(attribute,indicator)
# Assign true coefficients for treatments
#Beta_js
coefs <- data_frame(coef_val=rnorm(n=length(c(treatments1,treatments2)),mean=0,sd=1),
treat_label=c(treatments1,treatments2))
# Create cluster covariance in the errors
sigma_matrix <- matrix(2,nrow=4,ncol=4)
diag(sigma_matrix) <- 4
# Add on the outcome as a normal draw, treatment coefficients, interaction coefficient, group errors/interaction by respondent
by_resp <- gather(by_resp,treatment,appeal_type,actor,gift) %>%
left_join(coefs,by=c('appeal_type'='treat_label'))
# Record interaction coefficient (true estimate of interest)
true_effect <- rnorm(n=1,mean=0.5,sd=0.3)
by_resp <- select(by_resp,-treatment) %>% spread(appeal_type,coef_val) %>%  group_by(respondent) %>% mutate(error=MASS::mvrnorm(1,mu=rep(0,4),Sigma=sigma_matrix)) %>% ungroup
# interaction coefficient only in function if military==TRUE
by_resp <- mutate(by_resp,int_coef=true_effect*rbinom(n = n(),prob = 0.2,size=1),
int_coef=if_else(military!=0,int_coef,0))
by_resp <- lapply(by_resp, function(x) {
if(is.double(x)) {
x[is.na(x)] <- 0
}
return(x)
}) %>% as_data_frame
# To make the outcome, need to turn the dataset long
# However, we now need to drop the reference categories
# Drop one dummy from actor/gift to prevent multicollinearity = reforms + government combination
out_var <- gather(by_resp,var_name,var_value,-respondent,-task,-cluster) %>%
filter(!(var_name %in% c('reforms','government'))) %>%
group_by(respondent,task) %>% summarize(outcome=sum(var_value)+5)
combined_data <- left_join(out_var,by_resp,by=c('respondent','task'))
# Re-estimate with a blocking variable
combined_data$Q <- c(rep(1,floor(nrow(combined_data)/2)),
rep(0,ceiling(nrow(combined_data)/2)))
combined_data$outcome <- if_else(combined_data$Q==1,combined_data$outcome+1,
combined_data$outcome)
# # Create data predictor matrix and estimate coefficients from the simulated dataset
#
to_lm <- ungroup(combined_data) %>% select(contracts.supply:reforms,int_coef,Q)
to_lm <- mutate_all(to_lm,funs(if_else(.!=0,1,.))) %>% mutate(outcome=combined_data$outcome)
#No post-stratification
# I don't estimate a constituent term for int_coef because it is assumed to be zero
results <- lm(outcome~contracts.supply + exprop.firm + exprop.income + military + MOI + MOJ + municipality +
parliament + permit.export + permit.import + permit.reg + president +
int_coef:military,data=to_lm)
results_clust <- cluster.vcov(results,cluster = combined_data$respondent)
pvals_adj <- coeftest(results,vcov.=results_clust)[-1,4]<0.05
pvals_orig <- coeftest(results)[-1,4]<0.05
total_sig_orig <- mean(pvals_orig)
total_sig_adj <- mean(pvals_adj)
int_sig_orig <- pvals_orig['military:int_coef']
int_sig_adj <- pvals_adj['military:int_coef']
# Now run the poststratification model
results_ps <- lm(outcome~contracts.supply + exprop.firm + exprop.income + military + MOI + MOJ + municipality +
parliament + permit.export + permit.import + permit.reg + president +
int_coef:military + Q,data=to_lm)
results_clust <- cluster.vcov(results,cluster = combined_data$respondent)
pvals_adj <- coeftest(results_ps,vcov.=results_clust)[-1,4]<0.05
pvals_orig <- coeftest(results_ps)[-1,4]<0.05
total_sig_orig_blocker <- mean(pvals_orig)
total_sig_adj_blocker <- mean(pvals_adj)
int_sig_orig_blocker <- pvals_orig['military:int_coef']
int_sig_adj_blocker <- pvals_adj['military:int_coef']
out_results <- data_frame(int_sig_adj,int_sig_orig,int_sig_adj_blocker,int_sig_orig_blocker,
total_sig_adj,total_sig_orig,total_sig_adj_blocker,
total_sig_orig_blocker,abs_true_effect=abs(true_effect),
true_effect=true_effect,
est_effect=coef(results)['military:int_coef'],
est_effect_ps=coef(results)['military:int_coef'])
})
out_data <- bind_rows(out_data)
return(out_data)
},mc.cores=parallel::detectCores(),mc.preschedule=FALSE)
#save the data for inspection
all_sims_data <- bind_rows(all_sims) %>% mutate(sample_size=rep(sampled_seq,each=n_sims),
iter=rep(1:n_sims,times=num_breaks))
}
View(long_data)
if(run_sim==TRUE) {
saveRDS(object = all_sims_data,file='all_sims_data.rds')
} else {
all_sims_data <- readRDS('all_sims_data.rds')
}
# add in different calculations
all_sims_data <- group_by(all_sims_data,sample_size)  %>% mutate(sigeffVorig=ifelse(int_sig_orig,
est_effect,
NA),
sigeffVadj=ifelse(int_sig_adj,est_effect,NA),
sigeffVps_orig=ifelse(int_sig_orig_blocker,est_effect_ps,NA),
sigeffVps_adj=ifelse(int_sig_adj_blocker,est_effect_ps,NA),
powerVorig=int_sig_orig & (true_effect>0),
powerVadj=int_sig_adj & (true_effect>0),
powerVps_orig=int_sig_orig_blocker & (true_effect > 0),
powerVps_adj=int_sig_adj_blocker & (true_effect > 0),
SerrVorig=ifelse(int_sig_orig,1-(sign(est_effect)==sign(true_effect)),NA),
SerrVadj=ifelse(int_sig_adj,1-(sign(est_effect)==sign(true_effect)),NA),
SerrVps_orig=ifelse(int_sig_orig_blocker,
1-(sign(est_effect_ps)==sign(true_effect)),NA),
SerrVps_adj=ifelse(int_sig_adj_blocker,
1-(sign(est_effect_ps)==sign(true_effect)),NA),
MerrVorig=ifelse(int_sig_orig,abs(est_effect)/abs_true_effect,NA),
MerrVadj=ifelse(int_sig_adj,abs(est_effect)/abs_true_effect,NA),
MerrVps_orig=ifelse(int_sig_orig_blocker,abs(est_effect_ps)/abs_true_effect,NA),
MerrVps_adj=ifelse(int_sig_adj_blocker,abs(est_effect_ps)/abs_true_effect,NA))
long_data <- select(all_sims_data,matches('V|sample|iter')) %>% gather(effect_type,result,-sample_size,-iter) %>% separate(effect_type,into=c('estimate','estimation'),sep='V') %>%
mutate(estimate=factor(estimate,levels=c('sigeff','power','Serr','Merr'),
labels=c('Mean\nSignificant\nEffect',
'Mean\nPower',
'S-Error\nRate',
'M-Error\nRate')),
estimation=factor(estimation,levels=c('adj','orig','ps_adj','ps_orig'),
labels=c('No Post-Stratification\nClustered Errors\n',
'No Post-Stratification\nUn-clustered Errors\n',
'Post-Stratification\nClustered Errors\n',
'Post-Stratification\nUn-clustered Errors\n')))
long_data_treatment <- select(all_sims_data,matches('total|iter|sample')) %>% gather(effect_type,result,-sample_size,-iter) %>%
mutate(effect_type=factor(effect_type,levels=c('total_sig_adj',
'total_sig_orig',
'total_sig_adj_blocker',
'total_sig_orig_blocker'),
labels=c('No Post-Stratification\nClustered Errors\n',
'No Post-Stratification\nUn-clustered Errors\n',
'Post-Stratification\nClustered Errors\n',
'Post-Stratification\nUn-clustered Errors\n')))
# Plot a sample of the data (too big to display all of it)
if(nrow(long_data)>20000) {
DT::datatable(sample_n(ungroup(long_data),10000),rownames=FALSE)
} else {
DT::datatable(long_data,rownames=FALSE)
}
g_title <- guide_legend(title='')
filter(long_data,grepl('No Post',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('clust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
filter(long_data,grepl('Un-clustered',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('post_unclust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
filter(long_data,!grepl('Un-clustered',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('post_clust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
ggplot(long_data_treatment,aes(y=result,x=sample_size,linetype=effect_type,colour=effect_type)) +
theme_minimal() + stat_smooth() +
xlab('Sample Size') + ylab("") +
theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Dark2') + guides(linetype=g_title,colour=g_title) +
theme(legend.position = 'bottom')
ggsave('all_treat_rate.png',units='in',width=6)
blogdown::build_site()
blogdown::build_site()
knitr::opts_chunk$set(echo = TRUE)
#Required packages
require(ggplot2)
require(dplyr)
require(tidyr)
require(multiwayvcov)
require(lmtest)
# package MASS also used but not loaded
# != Note this simulation uses a version of mclapply for windows. You must have R package parallelsugar installed to use it if you are running windows.
# to install parallelsugar:
# install.packages('devtools')
# library(devtools)
# install_github('nathanvan/parallelsugar')
# If using Windows, parallelfunc comes from parallesugar, otherwise the standard mclapply is used
if(.Platform$OS.type=='windows') {
parallelfunc <- parallelsugar::mclapply_socket
} else {
parallelfunc <- parallel::mclapply
}
#Actually run the simulation or just load the data and look at it?
run_sim <- FALSE
# Max number of respondents fixed at 2700
num_resp <- 2700
# Number of iterations (breaks in sample size)
num_breaks <- 300
# Number of simulations to run per iteration
n_sims <- 1000
# Two treatment variables producing a cross-product of 7x7
treatments1 <- c('military','MOI','president','MOJ','parliament','municipality','government')
treatments2 <- c('exprop.firm','exprop.income','permit.reg','contracts.supply','permit.export','permit.import','reforms')
total_treat <- length(c(treatments1,treatments2))
grid_pair <- as.matrix(expand.grid(treatments1,treatments2))
print(head(grid_pair))
if(run_sim==TRUE) {
file.create('output_log.txt',showWarnings = FALSE)
# Need to randomize over the simulations so that parallelization works correctly on windows
sampled_seq <- sample(seq(100,num_resp,length.out = num_breaks))
all_sims <- parallelfunc(sampled_seq,function(x) {
out_probs <- 1:n_sims
cat(paste0("Now running simulation on data sample size ",x),file='output_log.txt',sep='\n',append=TRUE)
out_data <- lapply(1:n_sims, function(j) {
total_probs <- sapply(1:x,function(x) {
treat_rows <- sample(1:nrow(grid_pair),4)
treatments_indiv <- c(grid_pair[treat_rows,])
return(treatments_indiv)
})
by_resp <- t(total_probs)
by_resp <- as_data_frame(by_resp)
names(by_resp) <- c(paste0('actor.',1:4,"_cluster",c(1,1,2,2)),paste0('gift.',1:4,"_cluster",c(1,1,2,2)))
by_resp$respondent <- paste0('Respondent_',1:nrow(by_resp))
by_resp <- gather(by_resp,attribute,indicator,-respondent) %>% separate(attribute,into=c('attribute','cluster'),sep='_') %>%
separate(attribute,into=c('attribute','task')) %>% spread(attribute,indicator)
# Assign true coefficients for treatments
#Beta_js
coefs <- data_frame(coef_val=rnorm(n=length(c(treatments1,treatments2)),mean=0,sd=1),
treat_label=c(treatments1,treatments2))
# Create cluster covariance in the errors
sigma_matrix <- matrix(2,nrow=4,ncol=4)
diag(sigma_matrix) <- 4
# Add on the outcome as a normal draw, treatment coefficients, interaction coefficient, group errors/interaction by respondent
by_resp <- gather(by_resp,treatment,appeal_type,actor,gift) %>%
left_join(coefs,by=c('appeal_type'='treat_label'))
# Record interaction coefficient (true estimate of interest)
true_effect <- rnorm(n=1,mean=0.5,sd=0.3)
by_resp <- select(by_resp,-treatment) %>% spread(appeal_type,coef_val) %>%  group_by(respondent) %>% mutate(error=MASS::mvrnorm(1,mu=rep(0,4),Sigma=sigma_matrix)) %>% ungroup
# interaction coefficient only in function if military==TRUE
by_resp <- mutate(by_resp,int_coef=true_effect*rbinom(n = n(),prob = 0.2,size=1),
int_coef=if_else(military!=0,int_coef,0))
by_resp <- lapply(by_resp, function(x) {
if(is.double(x)) {
x[is.na(x)] <- 0
}
return(x)
}) %>% as_data_frame
# To make the outcome, need to turn the dataset long
# However, we now need to drop the reference categories
# Drop one dummy from actor/gift to prevent multicollinearity = reforms + government combination
out_var <- gather(by_resp,var_name,var_value,-respondent,-task,-cluster) %>%
filter(!(var_name %in% c('reforms','government'))) %>%
group_by(respondent,task) %>% summarize(outcome=sum(var_value)+5)
combined_data <- left_join(out_var,by_resp,by=c('respondent','task'))
# Re-estimate with a blocking variable
combined_data$Q <- c(rep(1,floor(nrow(combined_data)/2)),
rep(0,ceiling(nrow(combined_data)/2)))
combined_data$outcome <- if_else(combined_data$Q==1,combined_data$outcome+1,
combined_data$outcome)
# # Create data predictor matrix and estimate coefficients from the simulated dataset
#
to_lm <- ungroup(combined_data) %>% select(contracts.supply:reforms,int_coef,Q)
to_lm <- mutate_all(to_lm,funs(if_else(.!=0,1,.))) %>% mutate(outcome=combined_data$outcome)
#No post-stratification
# I don't estimate a constituent term for int_coef because it is assumed to be zero
results <- lm(outcome~contracts.supply + exprop.firm + exprop.income + military + MOI + MOJ + municipality +
parliament + permit.export + permit.import + permit.reg + president +
int_coef:military,data=to_lm)
results_clust <- cluster.vcov(results,cluster = combined_data$respondent)
pvals_adj <- coeftest(results,vcov.=results_clust)[-1,4]<0.05
pvals_orig <- coeftest(results)[-1,4]<0.05
total_sig_orig <- mean(pvals_orig)
total_sig_adj <- mean(pvals_adj)
int_sig_orig <- pvals_orig['military:int_coef']
int_sig_adj <- pvals_adj['military:int_coef']
# Now run the poststratification model
results_ps <- lm(outcome~contracts.supply + exprop.firm + exprop.income + military + MOI + MOJ + municipality +
parliament + permit.export + permit.import + permit.reg + president +
int_coef:military + Q,data=to_lm)
results_clust <- cluster.vcov(results,cluster = combined_data$respondent)
pvals_adj <- coeftest(results_ps,vcov.=results_clust)[-1,4]<0.05
pvals_orig <- coeftest(results_ps)[-1,4]<0.05
total_sig_orig_blocker <- mean(pvals_orig)
total_sig_adj_blocker <- mean(pvals_adj)
int_sig_orig_blocker <- pvals_orig['military:int_coef']
int_sig_adj_blocker <- pvals_adj['military:int_coef']
out_results <- data_frame(int_sig_adj,int_sig_orig,int_sig_adj_blocker,int_sig_orig_blocker,
total_sig_adj,total_sig_orig,total_sig_adj_blocker,
total_sig_orig_blocker,abs_true_effect=abs(true_effect),
true_effect=true_effect,
est_effect=coef(results)['military:int_coef'],
est_effect_ps=coef(results)['military:int_coef'])
})
out_data <- bind_rows(out_data)
return(out_data)
},mc.cores=parallel::detectCores(),mc.preschedule=FALSE)
#save the data for inspection
all_sims_data <- bind_rows(all_sims) %>% mutate(sample_size=rep(sampled_seq,each=n_sims),
iter=rep(1:n_sims,times=num_breaks))
}
if(run_sim==TRUE) {
saveRDS(object = all_sims_data,file='all_sims_data.rds')
} else {
all_sims_data <- readRDS('all_sims_data.rds')
}
# add in different calculations
all_sims_data <- group_by(all_sims_data,sample_size)  %>% mutate(sigeffVorig=ifelse(int_sig_orig,
est_effect,
NA),
sigeffVadj=ifelse(int_sig_adj,est_effect,NA),
sigeffVps_orig=ifelse(int_sig_orig_blocker,est_effect_ps,NA),
sigeffVps_adj=ifelse(int_sig_adj_blocker,est_effect_ps,NA),
powerVorig=int_sig_orig & (true_effect>0),
powerVadj=int_sig_adj & (true_effect>0),
powerVps_orig=int_sig_orig_blocker & (true_effect > 0),
powerVps_adj=int_sig_adj_blocker & (true_effect > 0),
SerrVorig=ifelse(int_sig_orig,1-(sign(est_effect)==sign(true_effect)),NA),
SerrVadj=ifelse(int_sig_adj,1-(sign(est_effect)==sign(true_effect)),NA),
SerrVps_orig=ifelse(int_sig_orig_blocker,
1-(sign(est_effect_ps)==sign(true_effect)),NA),
SerrVps_adj=ifelse(int_sig_adj_blocker,
1-(sign(est_effect_ps)==sign(true_effect)),NA),
MerrVorig=ifelse(int_sig_orig,abs(est_effect)/abs_true_effect,NA),
MerrVadj=ifelse(int_sig_adj,abs(est_effect)/abs_true_effect,NA),
MerrVps_orig=ifelse(int_sig_orig_blocker,abs(est_effect_ps)/abs_true_effect,NA),
MerrVps_adj=ifelse(int_sig_adj_blocker,abs(est_effect_ps)/abs_true_effect,NA))
long_data <- select(all_sims_data,matches('V|sample|iter')) %>% gather(effect_type,result,-sample_size,-iter) %>% separate(effect_type,into=c('estimate','estimation'),sep='V') %>%
mutate(estimate=factor(estimate,levels=c('sigeff','power','Serr','Merr'),
labels=c('Mean\nSignificant\nEffect',
'Mean\nPower',
'S-Error\nRate',
'M-Error\nRate')),
estimation=factor(estimation,levels=c('adj','orig','ps_adj','ps_orig'),
labels=c('No Post-Stratification\nClustered Errors\n',
'No Post-Stratification\nUn-clustered Errors\n',
'Post-Stratification\nClustered Errors\n',
'Post-Stratification\nUn-clustered Errors\n')))
long_data_treatment <- select(all_sims_data,matches('total|iter|sample')) %>% gather(effect_type,result,-sample_size,-iter) %>%
mutate(effect_type=factor(effect_type,levels=c('total_sig_adj',
'total_sig_orig',
'total_sig_adj_blocker',
'total_sig_orig_blocker'),
labels=c('No Post-Stratification\nClustered Errors\n',
'No Post-Stratification\nUn-clustered Errors\n',
'Post-Stratification\nClustered Errors\n',
'Post-Stratification\nUn-clustered Errors\n')))
# Plot a sample of the data (too big to display all of it)
if(nrow(long_data)>20000) {
DT::datatable(sample_n(ungroup(long_data),10000),rownames=FALSE)
} else {
DT::datatable(long_data,rownames=FALSE)
}
g_title <- guide_legend(title='')
filter(long_data,grepl('No Post',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('clust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
filter(long_data,grepl('Un-clustered',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('post_unclust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
filter(long_data,!grepl('Un-clustered',estimation)) %>% ggplot(aes(y=result,x=sample_size,linetype=estimation)) +
theme_minimal() + stat_smooth(colour='red') +
xlab('Sample Size') + ylab("") +
facet_wrap(~estimate,scales='free') + theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Accent') + guides(colour=g_title,linetype=g_title) +
theme(legend.position = 'bottom')
ggsave('post_clust_err.png',units='in',width=6)
g_title <- guide_legend(title='')
ggplot(long_data_treatment,aes(y=result,x=sample_size,linetype=effect_type,colour=effect_type)) +
theme_minimal() + stat_smooth() +
xlab('Sample Size') + ylab("") +
theme(panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank()) +
scale_color_brewer(palette='Dark2') + guides(linetype=g_title,colour=g_title) +
theme(legend.position = 'bottom')
ggsave('all_treat_rate.png',units='in',width=6)
knitr::kable(slice(ungroup(long_data)1:10))
knitr::kable(slice(ungroup(long_data),1:10))
blogdown::build_site()
blogdown::build_site()
require(stringr)
long_data %>% mutate(estimate=str_remove(estimate,"\\n"),
estimation=str_remove(estimation,"\\n")) %>%
knitr::kable(slice(ungroup(long_data),1:10))
long_data %>% ungroup %>%
slice(1:10) %>%
mutate(estimate=str_remove(estimate,"\\n"),
estimation=str_remove(estimation,"\\n")) %>%
knitr::kable(.)
long_data %>% ungroup %>%
slice(1:10) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_remove(estimation,"\\n", " ")) %>%
knitr::kable(.)
long_data %>% ungroup %>%
slice(1:10) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_remove(estimation,"\\n", " ")) %>%
knitr::kable(.)
long_data %>% ungroup %>%
slice(1:10) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_replace(estimation,"\\n", " ")) %>%
knitr::kable(.)
blogdown::build_site()
lookat <- long_data %>% ungroup %>%
slice(1:10) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_replace(estimation,"\\n", " "))
View(lookat)
blogdown::build_site()
long_data %>% ungroup %>%
slice(1:10) %>%
select(-estimation) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_replace(estimation,"\\n", " ")) %>%
DT::datatable(.)
long_data %>% ungroup %>%
slice(1:10) %>%
select(-estimation) %>%
mutate(estimate=str_replace(estimate,"\\n"," "),
estimation=str_replace(estimation,"\\n", " ")) %>%
DT::datatable(.)
long_data %>% ungroup %>%
slice(1:10) %>%
select(-estimation) %>%
mutate(estimate=str_replace(estimate,"\\n"," ")) %>%
DT::datatable(.)
blogdown::build_site()
blogdown::build_site()
?knitr::kable
install.packages("kableExtra")
require(kableExtra)
blogdown::build_site()
blogdown::build_site()
blogdown::build_site()
