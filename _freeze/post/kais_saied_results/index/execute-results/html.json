{
  "hash": "7b97dcbca99e5be33fbd306561adc98c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"What Do Tunisians Really Think About President Kais Saied?\"\nauthor: \"Robert Kubinec and Amr Yakout\"\ndate: \"2023-08-16T15:00:00\"\nformat:\n  html:\n    toc: true\nimage: \"../../files/img/headers/saied.jpeg\"\ncategories: [\"R\", \"Tunisia\", \"Democracy\"]\nbibliography: \"../../files/references.bib\"\ndescription: \"I reproduce results from our recent survey experiment showing that people are opposed to President Kais Saied but prefer not to report their opposition directly.\"\n---\n\n\n\n\n\n\nThis Rmarkdown document contains code and data for the Kais Saied survey experiment by Robert Kubinec and Amr Yakout. This survey was fielded using an online panel in Tunisia during August of 2023. The survey experiment involved providing half the sample a direct question about whether they supported Kais Saied's move to suspend parliament and centralize power in his hands, and the other half of the sample had a randomized response question designed to allow them to answer truthfully without being identified. This experiment was pre-registered and the pre-registration can be accessed from [this link](https://www.robertkubinec.com/files/preregistration_tunisia_imf_survey.pdf).\n\nThis document was drafted to allow people to verify our results using the raw data. The survey data included has been stripped of any identifying information about respondents, but it does include the actual answers from the survey so that all analyses can be reproduced. You can access the code file and the raw data from this Github repository: <https://github.com/saudiwin/saudiwin.github.io/tree/sources/content/post> (file is entitled `kais_saied_results.Rmd` and the data file is in the `data/` subfolder). The survey data can be found in the `data/` folder as `kais_saied_survey.csv`.\n\nThis Quarto document includes embedded R code that loads the survey data and estimates the Stan model for proportion of people who support Kais Saied, and compares it to the direct question to see if there is sensitive survey bias. At present there are a total of 913 completed responses.\n\nAll questions about the analysis should be directed to Robert Kubinec at [rmk7\\@nyu.edu](mailto:rmk7@nyu.edu).\n\n## Robustness check: time of completion\n\nIn this section I show some general statistics for the data. In particular, I look at how long it takes people to complete the survey. In the plot below I show the average duration in minutes over time for each survey response. The plot shows that most people took the survey in about 10 to 30 minutes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_data %>% \n  filter(`Duration (in seconds)`<10000) %>% \n  mutate(Duration=`Duration (in seconds)`/60) %>% \n  ggplot(aes(y=Duration,x=StartDate)) +\n  geom_point() +\n  scale_y_log10() +\n  geom_smooth()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/completion_time-1.png){width=672}\n:::\n:::\n\n\n\n\nThe plot also shows that data collection started in late July and continued until mid-August. Data came in fairly regularly on a daily basis.\n\n## Survey Design\n\nIn the survey we implemented a form of a randomized response question that is designed to help people report answers on a survey that they may be embarrassed about or in danger if they report. The question was originally developed for private medical information like abortion or HIV infections, and has been extended to cover crime, drug use and corruption reporting. See @vandenhout2002, @gingerich2016 and @blair2015 for more information.\n\nThe theory behind a randomized response is to inject randomness into the survey question. Theoretically it is similar to approaches in cryptography that use [random numbers to encode online data using keys](https://en.wikipedia.org/wiki/Applications_of_randomness). In our case, we used naturally ocurring randomness related to people's birthdays. Because we did not ask for respondents' birth dates, and the month in which one is born is essentially random, we can use that naturally occurring randomness to encode their responses.\n\nTo test for how much we could encourage people to respond truthfully, we randomly assigned each respondent to receive one of the two questions below:\n\nDirect Question\n\n1.  Do you oppose President Kais Saied's moves to change Tunisia's constitution and close the parliament?\n    1.  Yes\n    2.  No\n\nRandomized Response\n\nWe understand that politics in Tunisia is sensitive right now. This question is worded so that you can tell us what you think but still protect your privacy. Because we don't know when your mother was born, we also won't know for sure your political opinion.\n\n1.  My mother's birth date is in January, February or March.\n2.  I oppose President Kais Saied's moves to change Tunisia's constitution and close the parliament.\n\nPlease pick the answer that best represents whether these statements are true of you:\n\n1.  Both statements are true OR neither is true.\n2.  One of the two statements is true.\n\nWhile explaining how this question works is beyond the scope of this note, we again refer to the linked paper above for the statistical mechanics. As long as the respondent reads and follows the instructions, they can report their opposition (or support) for Kais Saied's power grab without us being able to know their true response. Essentially, we can't separate their answer from whether their mother's birthday is in a given month, and as a result, the individual answers are encoded. For any respondent, we have no idea whether they oppose Saied or not.\n\nHowever, the beauty of this method is that even though we don't know any one person's response, we *can* estimate how many in people in total support or oppose Saied. When we aggregate responses, we can take into account that on average $\\frac{1}{4}$ of our respondents will have mothers who were born in those months. Using statistical models that we estimate below, we can find out how many people truly oppose Saied, and also how many people appear to be under-reporting their opposition relative to the direct question.\n\n## Sensitivity Estimates\n\nIn this section we show several different ways that we calculate the true number of people who are opposed to Kais Saied. We first use a simple Bayesian calculation based on the beta distribution that was specified in the pre-registration linked above. We then look at other existing R packages that are used for randomized response questions and then we implement a custom Bayesian model that allows us to jointly model both the randomized response and the direct question. We also use this custom model to allow us to adjust for biases in using online panels that may not be fully representative.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# proportion selecting birthday response\n\nlambda <- table(survey_data$kais_rr)\nlambda <- lambda[2]/sum(lambda)\n\nN <- sum(as.numeric(!is.na(survey_data$kais_rr) & survey_data$FL_63_DO_saied_sensitive==1))\n\nto_stan_data <- list(success_cm=N*((lambda - .75)/(-.5)),\n                     fail_cm= N*(1-((lambda - .75)/-.5)),\n                     success_d=sum(as.numeric(survey_data$kais_direct==\"Yes\" & survey_data$FL_63_DO_saied_nonsensitive==1),na.rm=T),\n                     fail_d=sum(as.numeric(survey_data$kais_direct==\"No\" & survey_data$FL_63_DO_saied_nonsensitive==1),na.rm=T))\n\nfit_mod <- sen_mod$sample(chains=4, cores=4, data=to_stan_data,refresh=0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 parallel chains...\n\nChain 1 finished in 0.0 seconds.\nChain 2 finished in 0.0 seconds.\nChain 3 finished in 0.0 seconds.\nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.2 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nfit_mod$summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 10\n  variable          mean   median     sd    mad       q5      q95  rhat ess_bulk\n  <chr>            <dbl>    <dbl>  <dbl>  <dbl>    <dbl>    <dbl> <dbl>    <dbl>\n1 lp__          -853.    -852.    1.23   1.01   -855.    -851.     1.00    1998.\n2 pi_hat           0.507    0.507 0.0244 0.0250    0.468    0.548  1.00    3616.\n3 d_hat            0.298    0.298 0.0218 0.0218    0.262    0.334  1.00    3943.\n4 d_hat_binomi…    0.298    0.297 0.0212 0.0211    0.263    0.333  1.00    3934.\n5 estimand         0.210    0.210 0.0323 0.0319    0.157    0.264  1.00    3622.\n# ℹ 1 more variable: ess_tail <dbl>\n```\n\n\n:::\n:::\n\n\n\n\nWe can plot the estimated bias as the difference between the average proportion of those responding affirmative to the direct question and the calculated level of opposition to Saied from the randomized response question:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimand <- c(fit_mod$draws(\"estimand\"))\n\nmcmc_dens(fit_mod$draws(\"estimand\")) + \n  theme_tufte() +\n  labs(x=\"Percent Increase Over Direct Question\") +\n  scale_x_continuous(labels=scales::percent_format()) + \n  ggtitle(\"Difference Between Direct Question and Encrypted Question\",\n          subtitle=\"Opposition to Saied's Coup\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_bias-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"bias_calc.png\",width=5,height=4)\n```\n:::\n\n\n\n\nOur basic model shows that approximately 21% of respondents reported anti-Saied preferences in the randomized response method versus the direct question. The 5% - 95% uncertainty interval is from 15.7 to 26.4 .\n\nThe full posterior density of the bias-corrected estimate is:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_dens(fit_mod$draws(\"pi_hat\")) + theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_true-1.png){width=672}\n:::\n:::\n\n\n\n\nComparing the two estimates as intervals (`pi_hat` is the true level of opposition to Saied and `d_hat` is the proportion from the direct question):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_intervals(fit_mod$draws(c(\"pi_hat\",\"d_hat\"))) + theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/compare_interval-1.png){width=672}\n:::\n:::\n\n\n\n\n## Alternative Estimation: RRreg\n\nIn this section we use the R package `RRreg` to check these calculations using a more traditional means for estimating sensitive proportions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest_rreg <- RRuni(response=as.numeric(comp_data_rr$kais_rr==\"Both statements are true OR neither is true.\" & comp_data_rr$FL_63_DO_saied_sensitive==1),\n                  p=.25,\n                  model=\"Crosswise\",MLest = TRUE)\n\nsummary(est_rreg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCrosswise Model with p = 0.25\nSample size: 425\n\n   Estimate   StdErr      z  Pr(>|z|)    \npi 0.507059 0.048563 10.441 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\ns1 <- summary(est_rreg)\n```\n:::\n\n\n\n\nLet's compare these estimates with plots:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest_beta <- fit_mod$summary()\n\nest_data <- tibble(estimate=c(s1$coefficients[,1],\n                              est_beta$median[est_beta$variable==\"pi_hat\"]),\n                   low=c(s1$coefficients[,1]-1.96*(s1$coefficients[,2]),\n                         est_beta$q5[est_beta$variable==\"pi_hat\"]),\n                   high=c(s1$coefficients[,1]+1.96*(s1$coefficients[,2]),\n                         est_beta$q95[est_beta$variable==\"pi_hat\"]),\n                   estimator=c(\"RRreg\",\"Bayes\"))\n\nest_data %>% \n  ggplot(aes(y=estimate,x=estimator)) +\n  geom_linerange(aes(ymin=low,\n                     ymax=high)) +\n  geom_point() +\n   theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/compare_est-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can see that they are similar estimates, although the R package has higher uncertainty than the simple Bayesian estimate.\n\n## Alternative Estimator: rr\n\nWe can also use the R package `rr` which uses the EM algorithm as opposed to `RRreg` which uses more conventional optimization.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_data_rr$gender_two <- factor(comp_data_rr$gender,\n                                  exclude=\"Other:\")\ncomp_data_rr <- filter(comp_data_rr, !is.na(gender_two))\n# need to switch the outcome\ncomp_data_rr$kais_rr_num_switch <- 1 - comp_data_rr$kais_rr_num\nrr_est <- rrreg(kais_rr_num_switch ~ as.character(gender_two), \n                data=comp_data_rr,\n                      p=.75,\n                      design='mirrored')\n\n# predict sensitive trait\n\npred_rr <- predict(rr_est,quasi.bayes = T)\nmean(pred_rr$est)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5006138\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pred_rr$est[comp_data_rr$gender_two==\"Male\"],na.rm=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5191125\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(pred_rr$est[comp_data_rr$gender_two==\"Female\"],na.rm=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4720857\n```\n\n\n:::\n\n```{.r .cell-code}\npred_rr_mean <- predict(rr_est,quasi.bayes = T,avg=T)\n```\n:::\n\n\n\n\nThis number seems very close to our other estimators. Again, the uncertainty seems larger than the simple Bayesian method. Minimal gender differences over who is more or less likely to oppose Saied.\n\nWe can plot this estimate against the others:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest_data <- tibble(estimate=c(s1$coefficients[,1],\n                              est_beta$median[est_beta$variable==\"pi_hat\"],\n                              pred_rr_mean$est),\n                   low=c(s1$coefficients[,1]-1.96*(s1$coefficients[,2]),\n                         est_beta$q5[est_beta$variable==\"pi_hat\"],\n                         pred_rr_mean$ci.lower),\n                   high=c(s1$coefficients[,1]+1.96*(s1$coefficients[,2]),\n                         est_beta$q95[est_beta$variable==\"pi_hat\"],\n                         pred_rr_mean$ci.upper),\n                   estimator=c(\"RRreg\",\"Bayes\",\"EM\"))\n\nest_data %>% \n  ggplot(aes(y=estimate,x=estimator)) +\n  geom_linerange(aes(ymin=low,\n                     ymax=high)) +\n  geom_point() + theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/est_compare_three-1.png){width=672}\n:::\n:::\n\n\n\n\n## BRMS Model\n\nFinally, we define a brms custom family for the randomized response model using the confusion matrix approach of @vandenhout2002. This model is a variety of the Bernoulli distribution that takes into account the known probabilities of obtaining the true response. It jointly models both the randomized response model and the direct question, allowing us to estimate the bias directly rather than post-estimation. By implementing it in `brms`, we can make use of `brms` features like multilevel regression to allow us to do post-stratification adjustment of the survey responses with population data from Tunisia's 2014 census. This is our preferred specification.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(brms)\n\nstan_funs <- '\n  real sens_reg_lpmf(int y, real mu, real bias, matrix P, int T) {\n  \n    // generalized RR model from van der Hout and van der Heijden (2002)\n    // also see R package RRreg\n    \n    real out;\n    // need to impose a constraint on bias where it cannot be larger than mu\n    real bias_trans = mu * bias;\n    \n    if(T==1) {\n    \n      // treatment distribution (crosswise model)\n      \n      if(y==1) {\n      \n        out = P[2,1] * (1 - mu) + P[2,2] * mu;\n      \n      } else if(y==0) {\n      \n       out = P[1,1]*(1-mu) + P[1,2]*mu;\n      \n      }\n\n    } else if (T==0) {\n    \n      // control = direct question\n    \n      if(y==1) {\n      \n        out = mu - bias_trans;\n      \n      } else if(y==0) {\n      \n        out = (1 - mu) + bias_trans;\n      \n      }\n    \n    }\n    \n    return log(out); \n\n  }\n  \n  int sens_reg_rng(real mu, real bias, matrix P, int T) {\n  \n    real bias_trans = mu*bias;\n  \n    if(T==1) {\n    \n      return bernoulli_rng(P[2,1] * (1 - mu) + P[2,2] * mu);\n      \n    } else {\n    \n      return bernoulli_rng(mu - bias_trans);\n    \n    }\n\n  }'\n\n# define custom family\n\nfamily_sens_reg <- custom_family(\"sens_reg\",\n                                 dpars=c(\"mu\",\"bias\"),\n                                 links=c(\"logit\",\"logit\"),\n                                 type=\"int\",\n                                 lb=c(NA,NA),\n                                 ub=c(NA,NA),\n                                 vars=c(\"P\",\"vint1[n]\"))\n\n# define log-likelihood\n\nlog_lik_sens_reg <- function(i, prep) {\n  mu <- brms::get_dpar(prep, \"mu\", i = i)\n  y <- prep$data$Y[i]\n  treatment <- prep$data$vint1[i]\n  bias <- brms::get_dpar(prep, \"bias\", i = i)\n  \n  bias_trans <- bias*mu\n  \n  if(treatment==1) {\n    \n    if(y==1) {\n    \n      return(log(P[2,1] * (1 - mu) + P[2,2] * mu))\n  \n    } else {\n      \n      return(log(P[1,1]*(1-mu) + P[1,2]*mu))\n    \n    }\n    \n  } else {\n    \n    if(y==1) {\n      \n      return(log(mu - bias_trans))\n      \n    } else {\n      \n      return(log((1 - mu) + bias_trans))\n      \n    }\n    \n  }\n  \n\n}\n\n# define posterior predictions\n\nposterior_predict_sens_reg <- function(i, prep, ...) {\n  \n  mu <- brms::get_dpar(prep, \"mu\", i = i)\n  bias <- brms::get_dpar(prep, \"bias\", i = i)\n  y <- prep$data$Y[i]\n  treatment <- prep$data$vint1[i]\n  \n  bias_trans <- mu*bias\n\n  if(treatment==1) {\n    \n    out <- rbinom(n=length(mu),size=1,prob=P[2,1] * (1 - mu) + P[2,2] * mu)\n    \n  } else {\n    \n    out <- rbinom(n=length(mu),size=1,prob=mu - bias_trans)\n    \n  }\n  \n  return(out)\n  \n}\n\n# define posterior expectation (equal to latent variable pi)\n\nposterior_epred_sens_reg <- function(prep,...) {\n\n  mu <- brms::get_dpar(prep, \"mu\")\n  bias <- brms::get_dpar(prep, \"bias\")\n\n  mu\n\n}\n\nposterior_epred_bias_sens_reg <- function(prep,...) {\n\n  mu <- brms::get_dpar(prep, \"mu\")\n  bias <- brms::get_dpar(prep, \"bias\")\n\n  bias*mu\n\n}\n\nP <- getPW(\"Warner\",p=.25)\n\nall_stanvars <- stanvar(x=P,block = \"data\") + \n  stanvar(scode=stan_funs,block=\"functions\")\n\nsurvey_data$age_cat_order <- ordered(survey_data$age_cat)\n\nfit1 <- brm(bf(kais_combined | vint(treatment) ~ gender*mo(age_cat_order) + (1|gov)), \n            data=survey_data,\n            family=family_sens_reg,\n            stanvars=all_stanvars,\n            prior=prior(beta(1,1),class=\"bias\") + \n              prior(normal(0,5), class=\"b\"),\n            chains=2,cores=2,control=list(max_treedepth=11,\n                                          adapt_delta=0.95),\n            backend = \"cmdstanr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 2 parallel chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 44.7 seconds.\nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 61.7 seconds.\n\nBoth chains finished successfully.\nMean chain execution time: 53.2 seconds.\nTotal execution time: 61.8 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\npp_check(fit1, type=\"bars\",ndraws=500)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/define_brms_rr-1.png){width=672}\n:::\n\n```{.r .cell-code}\nloo(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputed from 2000 by 880 log-likelihood matrix\n\n         Estimate   SE\nelpd_loo   -576.8  8.9\np_loo        10.6  0.5\nlooic      1153.7 17.9\n------\nMonte Carlo SE of elpd_loo is 0.1.\n\nAll Pareto k estimates are good (k < 0.5).\nSee help('pareto-k-diagnostic') for details.\n```\n\n\n:::\n\n```{.r .cell-code}\ngov_cats <- ranef(fit1,groups = \"gov\")$gov[,,1] %>% as_tibble %>% \n  mutate(level=row.names(ranef(fit1,groups = \"gov\")$gov[,,1]))\n```\n:::\n\n\n\n\nPlot this additional type of estimation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_latent_draws <- posterior_epred(fit1)\n\nget_latent_est <- tibble(median=median(get_latent_draws),\n                         high=quantile(apply(get_latent_draws, 1, median),.95),\n                         low=quantile(apply(get_latent_draws, 1, median),.05))\n\n# get estimate of bias\n\nprep_bias <- prepare_predictions(fit1)\n\nbias_trans <- posterior_epred_bias_sens_reg(prep_bias)\n\nbias_trans_est <- tibble(bias_est_low=quantile(apply(bias_trans,1,median),.05),\n                         bias_est=median(apply(bias_trans,1,median)),\n                         bias_est_high=quantile(apply(bias_trans,1,median),.95))\n\nest_data <- tibble(estimate=c(s1$coefficients[,1],\n                              est_beta$median[est_beta$variable==\"pi_hat\"],\n                              pred_rr_mean$est,\n                              get_latent_est$median),\n                   low=c(s1$coefficients[,1]-1.96*(s1$coefficients[,2]),\n                         est_beta$q5[est_beta$variable==\"pi_hat\"],\n                         pred_rr_mean$ci.lower,\n                         get_latent_est$low),\n                   high=c(s1$coefficients[,1]+1.96*(s1$coefficients[,2]),\n                         est_beta$q95[est_beta$variable==\"pi_hat\"],\n                         pred_rr_mean$ci.upper,\n                         get_latent_est$high),\n                   estimator=c(\"RRreg\",\"Bayes\",\"EM\",\"Bayes_Reg\"))\n\nest_data %>% \n  ggplot(aes(y=estimate,x=estimator)) +\n  geom_linerange(aes(ymin=low,\n                     ymax=high)) +\n  geom_point() + theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/all_plot-1.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(bias_trans_est)\n```\n\n::: {.cell-output-display}\n\n\n| bias_est_low| bias_est| bias_est_high|\n|------------:|--------:|-------------:|\n|    0.1356792| 0.229125|     0.3196246|\n\n\n:::\n:::\n\n\n\n\nAgain, we see that all of the estimates are quite similar. In the last section we compare them directly with a simulation, which shows that the two Bayesian estimators are both accurate and have good coverage, while `RRreg` is accurate but understates uncertainty in general.\n\n## Adjustment with MRP\n\nGiven that the data come from an online panel, we want to use Tunisian 2014 census data to adjust these findings by age, sex and governorate. This will account for a considerable (though not all) amount of sample selection bias due to the online survey frame. We will use random effects to model the influence of the sample frame on the outcome.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(census)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  gender gov     pop age_cat age_cat_order    prop\n  <chr>  <chr> <dbl> <fct>   <ord>           <dbl>\n1 Male   Tunis 17446 15-19   15-19         0.00120\n2 Female Tunis 16984 15-19   15-19         0.00117\n3 Male   Tunis 54142 20-24   20-24         0.00373\n4 Female Tunis 51111 20-24   20-24         0.00352\n5 Male   Tunis 48773 25-29   25-29         0.00336\n6 Female Tunis 45668 25-29   25-29         0.00315\n```\n\n\n:::\n:::\n\n\n\n\nWe will predict the sensitive trait for each census category, then stratify by summing over the proportion of population in each cell from the census data. We then plot this adjusted estimate.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# do for each condition, then average\n\ncensus_treat <- mutate(census, treatment=1)\ncensus_notreat <- mutate(census, treatment=0)\n\npred_data <- bind_rows(census_treat,\n                       census_notreat) %>% \n  mutate(prop=prop/2)\n\ntunisia_pred <- posterior_epred(fit1, newdata=pred_data) %>% \n  as_tibble %>% \n  mutate(draw=1:n()) %>% \n  gather(key=\"key\",\n         value=\"estimate\",-draw) %>% \n  mutate(draw=paste0(\"V\",draw)) %>% \n  spread(key=\"draw\",value=\"estimate\") %>% \n  mutate(key=as.numeric(stringr::str_remove(key, \"V\")))\n\ntunisia_pred <- left_join(tunisia_pred, \n                          mutate(pred_data, key=1:n())) %>% \n  left_join(census) %>% \n  gather(key = \"draw\",\n         value= \"estimate\",\n         matches(\"V\",ignore.case=F))\n\n# aggregate to highest level\n\nagg_est <- tunisia_pred %>% \n  group_by(draw) %>% \n  summarize(est_adj = sum(estimate * prop))\n\nagg_est %>% \n  ggplot(aes(x=est_adj)) +\n  geom_density(fill=\"blue\",alpha=0.5,\n               colour=NA) + theme_tufte() +\n  labs(y=\"\",x=\"Percent Opposing Saied's Coup\") +\n  scale_x_continuous(labels=scales::percent_format()) +\n  geom_vline(aes(xintercept=mean(est_adj)),linetype=2) +\n   ggtitle(\"Estimated Number Who Oppose Saied's 2021 Coup\",\n          subtitle=\"Based on Statistical Analysis of Randomized Response Question\") +\n  annotate(\"text\",\n           x=.52,y=4,label=paste0(\"Most likely number: \",round(mean(agg_est$est_adj),\n                                                               3)*100,\"%\"),\n           hjust=0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mrp_adjust-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"num_oppose.png\",width=5,height=3)\n```\n:::\n\n\n\n\n`{quantile(agg_est$est_adj, c(0.05,.5,.95))}`\n\nA difference of approximately 1 percent between the adjusted estimate and the naive number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(apply(get_latent_draws, 1, mean),c(0.05,.5,.95))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       5%       50%       95% \n0.4351862 0.5194791 0.6011222 \n```\n\n\n:::\n:::\n\n\n\n\nNext we can aggregate these results to look at gender, age and governorate in terms of relative levels of Saied support. Given that there is substantial uncertainty due to the sensitive question design, these results are somewhat noisy and should be interpreted with caution.\n\n### Gender\n\nWhen we aggregate to the level of gender, we see that men are approximately 5% more likely than women to report opposition President Kais Saied.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# merge in census data\nplot_data_gender <- tunisia_pred %>% \n  group_by(gender,draw) %>% \n  mutate(prop_gender=pop/sum(pop)) %>% \n  summarize(est_gender=sum(estimate*prop_gender)) %>% \n  group_by(gender) %>% \n  summarize(median_gender=median(est_gender),\n            low_gender=quantile(est_gender,.05),\n            high_gender=quantile(est_gender,.95))\n\nselect(plot_data_gender,\n       y=\"median_gender\",\n       x=\"gender\",\n       high_y=\"high_gender\",\n       low_y=\"low_gender\") %>% \n  write_csv(\"plot_data_gender.csv\")\n\n  plot_data_gender %>% \n  ggplot(aes(y=median_gender,\n             x=gender)) +\n  geom_pointrange(aes(ymin=low_gender,\n                      ymax=high_gender)) +\n  scale_y_continuous(labels=scales::percent) +\n    labs(\"% Opposing Saied\") +\n  theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/gender_support-1.png){width=672}\n:::\n:::\n\n\n\n\n### Age\n\nThe plot below shows aggregated opposition by age. Approximately 60 percent of the youngest age category (18 to 19 year olds) oppose President Saied while only 40 percent of the oldest age category (80 and over) oppose President Saied. This pattern is noticeably stronger than that for gender, though there is still considerable uncertainty.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data_age <- tunisia_pred %>% \n  group_by(age_cat,draw) %>% \n  mutate(prop_age_cat=pop/sum(pop)) %>% \n  summarize(est_age_cat=sum(estimate*prop_age_cat)) %>% \n  group_by(age_cat) %>% \n  summarize(median_age_cat=median(est_age_cat),\n            low_age_cat=quantile(est_age_cat,.05),\n            high_age_cat=quantile(est_age_cat,.95)) %>% \n  mutate(age_cat=recode(age_cat, `80 year and more`=\"80+\")) \n  \n  select(plot_data_age,\n       y=\"median_age_cat\",\n       x=\"age_cat\",\n       high_y=\"high_age_cat\",\n       low_y=\"low_age_cat\") %>% \n  write_csv(\"plot_data_age.csv\")\n\n  plot_data_age %>% \n  ggplot(aes(y=median_age_cat,\n             x=age_cat)) +\n  geom_pointrange(aes(ymin=low_age_cat,\n                      ymax=high_age_cat)) +\n    scale_y_continuous(labels=scales::percent) +\n  scale_x_discrete(guide = guide_axis(n.dodge = 2))+\n  labs(y=\"% Opposing Saied\",x=\"\") +\n  ggtitle(\"Number Opposing Saied by Age Category\",\n         subtitle=\"Encrypted (Randomized) Response Question\") +\n   theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/age_support-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"age_cat.png\",width=5,height=3)\n```\n:::\n\n\n\n\n### Region\n\nFinally, the plot below shows predicted opposition by region. In general, more rural districts like Kebili, Beja and Kairouan report more opposition, but these differences are quite noisy. Differences between regions are not especially pronounced in the data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data_region <- tunisia_pred %>% \n  group_by(gov,draw) %>% \n  mutate(prop_gov=pop/sum(pop)) %>% \n  summarize(est_gov=sum(estimate*prop_gov)) %>% \n  group_by(gov) %>% \n  summarize(median_gov=median(est_gov),\n            low_gov=quantile(est_gov,.05),\n            high_gov=quantile(est_gov,.95))\n\n\nselect(plot_data_region,\n       x=\"median_gov\",\n       y=\"gov\",\n       high_x=\"high_gov\",\n       low_x=\"low_gov\") %>% \n  write_csv(\"plot_data_region.csv\")\n\nplot_data_region %>% \n  ggplot(aes(y=median_gov,\n             x=reorder(gov,median_gov))) +\n  coord_flip() +\n    labs(\"% Opposing Saied\") +\n  geom_pointrange(aes(ymin=low_gov,\n                      ymax=high_gov)) + theme_tufte()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/support_by_region-1.png){width=672}\n:::\n:::\n\n\n\n\n## Simulation Comparison: Univariate Vs. Regression\n\nIn this simulation we test the coverage and unbiasedness of the estimators, including our preferred Bayesian specification. The simulation shows that the estimators perform quite well at recovering the sensitive trait, and our Bayesian models have excellent coverage (the uncertainty they report is reasonable). We'll use the regression spec as the DGP along with our observed parameters for this study.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parallel)\n\n# confusion matrix\n\nP <- getPW(\"Warner\",.25)\n\n# assume N = 500, small sensitivity of 0.05\n\ntheta <- 0.3\nN <- 800\nbias <- 0.1\n\nsims <- 500\n\nif(run_sim) {\n  \n  over_sims <- lapply(1:sims, function(s) {\n  \n  # assign half to treatment, half to control\n  \n  treatment <- as.numeric(runif(N)>0.5)\n  \n  obs_response <- ifelse(treatment==1,\n                         as.numeric((P[2,1] * (1 - theta) + P[2,2]*theta)>runif(N)),\n                         as.numeric((theta - bias)>runif(N)))\n  \n  out_data <- tibble(y = obs_response,\n                     treatment=treatment)\n  \n  # define custom family as being upper and lower bounded for bias\n  \n  family_sens_reg <- custom_family(\"sens_reg\",\n                                 dpars=c(\"mu\",\"bias\"),\n                                 links=c(\"logit\",\"logit\"),\n                                 type=\"int\",\n                                 lb=c(NA,0),\n                                 ub=c(NA,1),\n                                 vars=c(\"P\",\"vint1[n]\"))\n  \n  # estimate model with brms\n\n  est_mod_brms <- brm(y | vint(treatment) ~ 1,\n                      family=family_sens_reg,\n                      stanvars=all_stanvars,\n                      data=out_data,\n                      #prior=prior(normal(0,10),class=\"bias\"),\n                      prior=prior(beta(1,1),class=\"bias\") +\n                        prior(normal(-0.84,10),class=\"Intercept\"),\n                      chains=1,\n                      cores=1,\n                      iter=1000,\n            backend = \"cmdstanr\")\n  \n  get_est_brms <- posterior::summarise_draws(as_draws(est_mod_brms, \"b_Intercept\"),\n                                             estimate=~median(plogis(.x)),\n                                             high=~quantile(plogis(.x),.95),\n                                             low=~quantile(plogis(.x),.05)) %>% \n    mutate(param=\"mu\") \n  \n  # calculate bias transformed\n  \n  bias_est <- as_draws_matrix(est_mod_brms, \"bias\")\n  \n  mu_trans <- posterior_epred(est_mod_brms) %>% apply(1,median)\n\n  bias_trans_est <- tibble(`95%`=quantile(bias_est * mu_trans,.95),\n                         estimate=median(bias_est * mu_trans),\n                         `5%`=quantile(bias_est * mu_trans,.05)) %>% \n    mutate(param=\"bias\")\n  \n  get_est_brms <- bind_rows(get_est_brms, bias_trans_est) %>% \n    mutate(model=\"Bayes BRMS\")\n  \n  # compare with RRreg\n  \n  est_freq <- RRuni(response=obs_response[treatment==1],\n                  p=.25,\n                  model=\"Crosswise\",MLest = TRUE)\n  \n  this_sum <- summary(est_freq)\n  \n  # now do cheap Bayes\n  \n  lambda <- mean(obs_response[treatment==1])\n  \n  sim_data2 <- list(success_cm=(sum(treatment))*((lambda - .75)/(-.5)),\n                     fail_cm= (sum(treatment))*(1-((lambda - .75)/-.5)),\n                     success_d=sum(obs_response[treatment==0]),\n                     fail_d=sum(1 - obs_response[treatment==0]))\n\n  fit_simple <- sen_mod$sample(chains=1, cores=1, data=sim_data2,refresh=0)\n  \n  simple_sum <- fit_simple$summary()\n  \n  mu <- try(tibble(estimates=c(simple_sum$median[simple_sum$variable==\"pi_hat\"],\n                     this_sum$coefficients[1,1],\n                     get_est_brms$estimate[get_est_brms$param==\"mu\"]),\n         q5=c(simple_sum$q5[simple_sum$variable==\"pi_hat\"],\n                     this_sum$coefficients[1,1] - 1.96*this_sum$coefficients[1,2],\n              get_est_brms$`5%`[get_est_brms$param==\"mu\"]),\n         q95=c(simple_sum$q95[simple_sum$variable==\"pi_hat\"],\n                     this_sum$coefficients[1,1] + 1.96*this_sum$coefficients[1,2],\n               get_est_brms$`95%`[get_est_brms$param==\"mu\"]),\n         models=c(\"RRreg\",\"Bayes Simple\",\"Bayes BRMS\"),\n         param=\"mu\") %>% \n    mutate(cov=theta > q5 & theta < q95,\n           sim=s))\n  \n  bias_est <- try(filter(get_est_brms, param==\"bias\") %>% \n    select(estimates=\"estimate\",\n           q5=\"5%\",\n           q95=\"95%\") %>% \n    mutate(cov=bias > q5 & bias < q95,\n           sim=s,\n           param=\"bias\",\n           models=\"brms\"))\n  \n  try(bind_rows(mu, bias_est))\n   \n  \n}) %>% bind_rows\n  \n  saveRDS(over_sims, \"data/over_sims.rds\")\n  \n} else {\n  \n  over_sims <- readRDS(\"data/over_sims.rds\")\n  \n}\n\n\n\nover_sims %>% group_by(models,param) %>% \n  summarize(mean_cov=mean(cov)) %>% \n  knitr::kable(caption=\"Coverage\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Coverage\n\n|models       |param | mean_cov|\n|:------------|:-----|--------:|\n|Bayes BRMS   |mu    |    0.906|\n|Bayes Simple |mu    |    0.956|\n|RRreg        |mu    |    0.568|\n|brms         |bias  |    0.908|\n\n\n:::\n\n```{.r .cell-code}\nover_sims %>% group_by(models,param) %>% \n  summarize(spread_CIs=sum(q95 - q5)) %>% \n  knitr::kable(caption=\"Total Variance\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Total Variance\n\n|models       |param | spread_CIs|\n|:------------|:-----|----------:|\n|Bayes BRMS   |mu    |   71.44307|\n|Bayes Simple |mu    |   96.11747|\n|RRreg        |mu    |   37.30712|\n|brms         |bias  |   73.93706|\n\n\n:::\n:::\n\n\n\n\nNow let's check bias.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#RMSE\n\nover_sims %>% group_by(models,param) %>% \n  summarize(mean_rmse=switch(unique(param),\n                             mu=sqrt(mean((estimates - theta)^2)),\n                             bias=sqrt(mean((estimates - bias)^2)))) %>% \n  knitr::kable(caption = \"RMSE\")\n```\n\n::: {.cell-output-display}\n\n\nTable: RMSE\n\n|models       |param | mean_rmse|\n|:------------|:-----|---------:|\n|Bayes BRMS   |mu    | 0.0419459|\n|Bayes Simple |mu    | 0.0485183|\n|RRreg        |mu    | 0.0487269|\n|brms         |bias  | 0.0459833|\n\n\n:::\n\n```{.r .cell-code}\nover_sims %>% group_by(models,param) %>% \n  summarize(abs_bias=switch(unique(param),\n                             mu=mean(abs(estimates - theta)),\n                             bias=mean(abs(estimates - bias)))) %>% \n  knitr::kable(caption = \"Mean Absolute Bias\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Mean Absolute Bias\n\n|models       |param |  abs_bias|\n|:------------|:-----|---------:|\n|Bayes BRMS   |mu    | 0.0341473|\n|Bayes Simple |mu    | 0.0388322|\n|RRreg        |mu    | 0.0390247|\n|brms         |bias  | 0.0377768|\n\n\n:::\n:::\n\n\n\n\n# References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}